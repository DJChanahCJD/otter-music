## 背景与问题
用户操作：在移动端曲目菜单点击“下一首播放”（即调用 store 的 `addToNextPlay(track)`）。  
现象：当前正在播放的曲目会被“重新触发播放”，同时出现类似“播放成功”的 toast（实际文案是“加载成功”）。

## 基于代码事实的结论（为什么会重新触发播放）
这次“重新触发播放”并非一定来自列表行的 `onClick -> onPlay -> togglePlay`，更主要的触发链路是 **音频加载 hook 被重新执行**：

1. 点击“下一首播放”会更新队列 `queue`
   - `addToNextPlay` 会构造 `newQueue = [...state.queue]` 并 `splice` 插入到 `currentIndex + 1`，最终 `return { queue: newQueue, currentIndex: newCurrentIndex, ... }`  
   - 代码位置：[music-store.ts:L384-L457](file:///c:/Users/DJCHAN/SE/2_GithubProject/otter-music/src/store/music-store.ts#L384-L457)

2. `useAudioTrackLoader` 订阅了 `queue`，并把 `queue/currentIndex/currentTrack` 等放进了 `useEffect` 依赖
   - 目前依赖数组包含 `queue`、`currentIndex`、`currentTrack` 等：  
     [useAudioTrackLoader.ts:L85-L233](file:///c:/Users/DJCHAN/SE/2_GithubProject/otter-music/src/hooks/useAudioTrackLoader.ts#L85-L233)
   - 只要 `addToNextPlay` 让 `queue` 的引用变化（新数组），该 effect 就会再次触发，即使“当前播放曲目本身没变”。

3. effect 重跑会执行 `audio.pause()` -> `audio.play()`，并弹出“加载成功”
   - 成功分支明确会 `toast.success("加载成功", ...)`：  
     [useAudioTrackLoader.ts:L155-L186](file:///c:/Users/DJCHAN/SE/2_GithubProject/otter-music/src/hooks/useAudioTrackLoader.ts#L155-L186)
   - 项目里未找到“播放成功”文案；用户看到的应是“加载成功”或系统 toast 叠加。

因此：**点击“下一首播放”改变了队列，间接触发了 useAudioTrackLoader 的重新加载逻辑，导致当前曲目被 pause+play，并出现“加载成功”toast。**

## 额外说明：与“误触列表行播放”是两条不同链路
- 列表行的点击入口确实存在：[MusicTrackItem.tsx:L75-L85](file:///c:/Users/DJCHAN/SE/2_GithubProject/otter-music/src/components/MusicTrackItem.tsx#L75-L85)
- 但本次“重新触发播放 + 加载成功 toast”的特征，更符合 `useAudioTrackLoader` 重跑（它会主动 `audio.play()` 并 toast），而不是单纯 `togglePlay()`。

## 计划：如何修复（最小改动，避免队列变更导致重载）
目标：队列仅“插入下一首”时，不应触发音频重新加载；只有当“当前曲目/音质/用户手势”等关键条件变化时才加载。

### 1) 收窄 useAudioTrackLoader 的订阅与依赖（核心修复）
修改文件：[useAudioTrackLoader.ts](file:///c:/Users/DJCHAN/SE/2_GithubProject/otter-music/src/hooks/useAudioTrackLoader.ts)

- 移除对 `queue` 与 `currentIndex` 的订阅（避免任何队列结构变化都触发 rerender/effect）
  - 删除：
    - `const queue = useMusicStore(s => s.queue);`
    - `const currentIndex = useMusicStore(s => s.currentIndex);`
  - 离线兜底 `findNextPlayableTrack(queue, currentIndex, ...)` 改为在 `load()` 内用 `useMusicStore.getState()` 读取最新值（不通过订阅触发 effect）。

- 精简 `useEffect` 依赖数组，只保留“真正决定要不要重新加载”的 primitive key
  - 仅依赖：
    - `hasUserGesture`
    - `quality`
    - `currentTrack?.id`
    - `currentTrack?.source`
    - `currentTrack?.url_id`（local 时作为 trackId）
  - 移除重复项与高频/无关项：
    - `currentTrack`（对象依赖容易误触发）
    - `queue/currentIndex`
    - `setIsPlaying/setIsLoading/...` 等 action 引用（可直接用 `useMusicStore.getState()` 取，或保持但不放依赖）

预期效果：点击“下一首播放”只会改变队列，不再触发该 effect 重跑，也就不会 `pause/play` 与“加载成功”toast。

### 2) 保险兜底：增加“同曲目同音质不重载”守卫（可选但推荐）
同样修改 [useAudioTrackLoader.ts](file:///c:/Users/DJCHAN/SE/2_GithubProject/otter-music/src/hooks/useAudioTrackLoader.ts)：

- 新增 `lastLoadKeyRef`，key = `${source}:${id}:${quality}`（local 用 url_id）  
- effect 触发后，如果 key 与 `lastLoadKeyRef.current` 相同，则直接 return，不执行 `pause/load/play/toast`。

价值：即使未来有人又把无关依赖加回去，仍能避免“队列变更触发重载”这类回归。

### 3) 验证与回归点
手动验证（移动端/小屏模拟优先）：
1. 播放歌曲 A（保持播放中）。
2. 打开 A 的移动端菜单，点击“下一首播放”（插入歌曲 B 或任意非当前曲目）。
3. 期望：
   - 不出现“加载中/加载成功”toast（或至少不重新出现该链路 toast）
   - A 不会短暂停顿/重新 play
   - 队列顺序正确变化，仍出现“已添加到下一首播放”toast（该 toast 来自 UI 层：[MusicTrackItem.tsx:L154-L164](file:///c:/Users/DJCHAN/SE/2_GithubProject/otter-music/src/components/MusicTrackItem.tsx#L154-L164)）
4. 回归：切歌、音质切换、离线兜底跳歌逻辑仍正常。

工程校验：
- `npm run typecheck`
- `npm run lint`
- `npm run build`（可选）

## 风险与回滚
- 风险：精简依赖后，若离线兜底逻辑依赖的 `queue/currentIndex` 不再触发 effect，需要确保它只在“加载当前曲目时”使用，并且取值来自 `getState()` 是最新的。
- 回滚：恢复对 `queue/currentIndex` 的订阅与依赖（不推荐），或移除第 2) 的 guard（若引入了）即可回退到当前行为。
